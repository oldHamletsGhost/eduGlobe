<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
<meta name="description" content="3D globe created using three.js"/>
<meta name="author" content="Greg Goldsberry"/>
<meta name="references" content="Mr. Droob & Team, creators of three.js"/>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />

<!-- <meta name="viewpoint" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/> -->

<title>Globe Query</title>

<script src="jquery1.7.2.min.js" type="text/javascript"></script>
<script src="jquery1.8.3.min.js" type="text/javascript"></script>
<script src="jgestures.js" type="text/javascript"></script>
<script src="three.js" type="text/javascript"></script>

<style>
	body{ 
		background-image:url(starField.jpg);
		/*background-position: center;*/
		background-repeat: no-repeat;
		background-size: cover;
    /*    
		
		
		-webkit-background-size: cover;
        -moz-background-size: cover;
        -o-background-size: cover;*/	
		}

	

	
</style>

</head>

<body>

	<div id="atlas"></div>
</body>

<script>

var atlas, camera, scene, renderer, light;
var globe;
var mouseX = 0, mouseY=0;

var windowHalfX = window.innerWidth/2;
var windowHalfY = window.innerHeight/2;

var mouse = new THREE.Vector2();
var projector = new THREE.Projector();

var targetRotationForX = 0, targetRotationForY =0;
var targetRotationOnMouseDownForX = 0, targetRotationOnMouseDownForY = 0, targetRotationOnMouseDown=0;
var mouseXOnMouseDown = 0, mouseYOnMouseDown = 0;
var radius = 150;

var rotate = true;

init();
//animate();
	function init(){
	
		//alert(window.screen.height);
		console.log("Device height: "+window.screen.height+", Device width: "+window.screen.width);
		console.log("scrollHeight: "+document.body.scrollHeight+" scrollWidth: "+document.body.scrollWidth);
	
		//hide scroll bars
		document.documentElement.style.overflow = 'hidden';
		document.body.scroll = "no";
	
		atlas = document.getElementById('atlas');		
		scene = new THREE.Scene();
		
		camera = new THREE.PerspectiveCamera(45, window.innerWidth/ window.innerHeight, 1, 1000);
		camera.position.z = 500;
		//scene.add(camera);
		
		globe = new THREE.Object3D();
		globe.name = "earth"
		
		var loader = new THREE.TextureLoader();
		
		loader.load('smallEarth.jpg', function (texture)
		{
			var geometry = new THREE.SphereGeometry(radius, 50, 50);
			var material = new THREE.MeshLambertMaterial({
				map: texture,
				overdraw: true
				//wireframe: true
			});
		
			var mesh = new THREE.Mesh(geometry, material);
			globe.add(mesh);
			//globe.add(addOthers(globe));		
		});
		
		scene.add(globe);
		
		
		// LIGHT
		light = new THREE.PointLight(0xffffff);
		light.position.set(0,0,0);
		scene.add(light);
		
		//TODO: Detect browser - create webGL for browsers who can support it; use canvas as fallback
		renderer = new THREE.CanvasRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		atlas.appendChild(renderer.domElement);

		document.addEventListener('mousedown', onDocumentMouseDown, false);		
		document.addEventListener('touchstart', onDocumentTouchStart, false);
		document.addEventListener('mousewheel', onMouseWheel, false);
		document.addEventListener('DOMMouseScroll', onMouseWheel, false);
		window.addEventListener('resize', onWindowResize, false );
		
		//renderer.render(scene, camera);
		requestAnimationFrame(render);
	}	
	
	$(document).ready(function(){
			var width =  $(window).width();
			var height = $(window).height();
			
			$('body.img').css("width", "100%").css("height","100%");
		
	
	});

	function onWindowResize(){

		windowHalfX = window.innerWidth / 2;
		windowHalfY = window.innerHeight / 2;

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );
		//$('body').css("background-size", document.body.scrollHeight, document.body.scrollWidth);
		$('body.img').css("width", "100%").css("height","100%");
	}
	
	function render(){
			
		requestAnimationFrame(render);
	/*	if (rotate == true){
			//globe.rotation.x += 0.01;
		}else{ */
			globe.rotation.x += (targetRotationForY - globe.rotation.x) *0.05;
			globe.rotation.y += (targetRotationForX - globe.rotation.y) *0.05;
	//	}
		renderer.render(scene, camera);
	}		
/*	
	function animate(){
		requestAnimationFrame(animate);
		render();
	}
	*/	
	/***** MOUSE EVENTS START******/	
	function onDocumentMouseDown(event){

		rotate = false;
		event.preventDefault();
		
		mouse.x = (event.clientX/window.innerWidth) * 2 - 1;
		mouse.y = -(event.clientY/window.innerHeight) * 2 + 1;

		//var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
		var vector = new THREE.Vector3(mouse.x, mouse.y, camera.near);
		projector.unprojectVector(vector, camera);
		
		var raycaster = new THREE.Raycaster( camera.position, vector.sub(camera.position).normalize() );
		var intersects = raycaster.intersectObjects(scene.getDescendants());
		
		//console.log(intersects.length);

		//DETECTS IF THE SPHERE IS TOUCHED
		if (intersects.length > 0) {
			//alert("sphere touched");		
		}else{
			
		//	alert("space touched");
		}	

		document.addEventListener('mousemove', onDocumentMouseMove, false);
		document.addEventListener('mouseup', onDocumentMouseUp, false);
		document.addEventListener('mouseout', onDocumentMouseOut, false);

		mouseXOnMouseDown = event.clientX - windowHalfX;
		mouseYOnMouseDown = event.clientY - windowHalfY;

		targetRotationOnMouseDownForX = targetRotationForX;
		targetRotationOnMouseDownForY = targetRotationForY;
	}
	
	function onDocumentMouseMove(e){
		mouseX =  e.clientX - windowHalfX;
		mouseY =  e.clientY - windowHalfY;	

		targetRotationForX = targetRotationOnMouseDownForX + (mouseX - mouseXOnMouseDown) * 0.05;
		targetRotationForY = targetRotationOnMouseDownForY + (mouseY - mouseYOnMouseDown) * 0.05;	
	}	
	
	function onDocumentMouseUp(){removeEventListeners();}
	function onDocumentMouseOut(){removeEventListeners();}
	
	function onMouseWheel(event){
		event.preventDefault();
		
		var e = window.event || event;		
		var delta = Math.max(-1, Math.min(1, (event.wheelDelta || e.detail)));
		
		if (delta == 1){
			if(globe.position.z > -510){globe.position.z -= 10;}
		}else{
			if (globe.position.z < 120){globe.position.z += 10;}
		}
	}
	
	function removeEventListeners(){
		document.removeEventListener('mousemove', onDocumentMouseMove, false);
		document.removeEventListener('mouseup', onDocumentMouseUp, false);
		document.removeEventListener('mouseout', onDocumentMouseOut, false);	
	}
	/****** MOUSE EVENTS END **********/
	
	/****** TOUCH EVENETS START *******/
	function onDocumentTouchStart( event ) {
		
		rotate = false;
		document.addEventListener('touchmove', onDocumentTouchMove, false);
		document.addEventListener('touchleave', onDocumentTouchLeave, false);
		document.addEventListener('touchend', onDocumentTouchEnd, false);
		$("#atlas").bind("pinchopen", onPinchOpen);
		$("#atlas").bind("pinchclose", onPinchClose);
		
		if ( event.touches.length == 1 ){	
			event.preventDefault();
			mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
			mouseYOnMouseDown = event.touches[ 0 ].pageY - windowHalfY;
			targetRotationOnMouseDownForX = targetRotationForX;
			targetRotationOnMouseDownForY = targetRotationForY;
		}
	}
	
	function onDocumentTouchMove( event ) {	
		if ( event.touches.length == 1 ){	
			event.preventDefault();
			mouseX = event.touches[ 0 ].pageX - windowHalfX;
			mouseY = event.touches[ 0 ].pageY - windowHalfY;
			targetRotationForX = targetRotationOnMouseDownForX + ( mouseX - mouseXOnMouseDown ) * 0.05;
			targetRotationForY = targetRotationOnMouseDownForY + ( mouseY - mouseYOnMouseDown ) * 0.05;
		}	
	}
	
	function onDocumentTouchLeave(event){
		document.removeEventListener('touchmove', onDocumentTouchMove, false);
		document.removeEventListener('touchleave', onDocumentTouchLeave, false);
		document.removeEventListener('touchend', onDocumentTouchEnd, false);
	}	
	
	function onDocumentTouchEnd(event){
		document.removeEventListener('touchmove', onDocumentTouchMove, false);
		document.removeEventListener('touchleave', onDocumentTouchLeave, false);
		document.removeEventListener('touchend', onDocumentTouchEnd, false);
	}	
	
	function onPinchOpen(event){
		event.preventDefault();
		if(globe.position.z > -540){globe.position.z -= 1;}
	}	
	
	function onPinchClose(event){
		event.preventDefault();
		if (globe.position.z < 330){globe.position.z += 1;}
	}
	
	/**** TOUCH EVENTS END *****/


	
	// CODE SCRAPS

	//NOTE: ambient light doesn't work with canvas
	//var ambientLight = new THREE.AmbientLight(0xffffff);
	//scene.add(ambientLight);
	
	//var directionalLight = new THREE.DirectionalLight(0xffffff);
	//directionalLight.position.set(1,1,1).normalize();
	//scene.add(directionalLight);
	/*
	var canvas = document.createElement('canvas');
	canvas.id = "canvas";
	canvas.width = 128;
	canvas.height = 128;
	
		function addOthers(globe){
	
		var rectLength = 120, rectWidth = 40;
		var rectShape = new THREE.Shape();
		rectShape.moveTo( 0,0 );
		rectShape.lineTo( 0, rectWidth );
		rectShape.lineTo( rectLength, rectWidth );
		rectShape.lineTo( rectLength, 0 );
		rectShape.lineTo( 0, 0 );
	
		var geometry = rectShape.createPointsGeometry();
		var material = new THREE.LineBasicMaterial({
			linewidth: 10, color: 0xFFFFFF
		});
		
		var addMesh = new THREE.Mesh(geometry, material);	
		addMesh.position.set(globe.position.x, globe.position.y, 0);
		addMesh.rotation.set(0, 0, 0);
		addMesh.scale.set( 1, 1, 1 );
		//rotation
		var line = new THREE.Line(geometry, material);
		//line.position.set(globe.position.x, globe.position.y, 0);
		line.position.set(6,30,70);
		line.rotation.set(-180, -1, -80);
		line.scale.set( 1, 1, 10 );
		
		return line;
	
	}
	
	
	
	*/
</script>



</html>